---
layout: post
title: "汇编语言笔记(十四)--内中断"
date: 2020-01-11
description: "汇编语言"
tag: 汇编语言
---
---

### 前言：

内中断 。

---


### 目录：

* <a href="#a" target="_self">概念</a>
* <a href="#b" target="_self">中断过程</a>
* <a href="#c" target="_self">中断处理程序和iret指令</a>
* <a href="#d" target="_self">除法错误中断的处理</a>
* <a href="#zg" target="_self">总结</a>

-------


### <span id = "a">概念：</span>

任何一个通用 CPU 都具备一种能力, 可以在执行完当前正在执行的指令之后, <br>

检测到从 CPU 外部发送过来的或者内部产生的一种特殊信息, <br>

并且可以立即对所接受到的信息进行处理，这种特殊的信息称为： 中断信息  <br>

中断意味着 CPU 不再继续向下执行, 而是转去处理这个特殊的信息， <br>

简单的讲，就是在做某件事情的时候，有东西突然打断你。 <br>

| 中断原因 | 中断类型码 |
| --- | --- |
| 除法错误 | 0 |
| 单步执行 | 1 |
| 执行 into 指令 | 4 |
| 执行 int 指令 | n |

中断类型码是中断来源信息的编码， 在 8086CPU 中使用一个字节的长度来编码中断源。 <br>

**中断处理程序**: 

CPU 在收到中断信息之后, 需要对中断进行处理 <br>

中断处理程序就是用来处理对应中断的程序. CPU 在收到中断信息之后,  <br>

就会转去执行对应的中断处理程序. 中断处理程序由程序员编写 <br>


**中断向量表**: 是中断向量的列表  <br>

**中断向量**: 是中断程序的入口地址

-----


### <span id = "b">中断过程：</span>

1. 从中断信息中获取中断类型码

2. 标志寄存器的值入栈

3. 设置标志寄存器的第八位 TF 和第九位 IF 的值为 0

4. CS 的内容入栈

5. IP 的内容入栈

6. 从内存地址为中断类型码 `*4` 和中断类型码 `*4+2` 的两个单元中读取中断处理程序的入口地址放入IP和CS中

相当于 `(IP)=(N*4) (CS)=(N*4+2)`

-----


### <span id = "c">中断处理程序和iret指令：</span>

中断处理程序的编写与子程序类似： <br>

1. 保存用到的寄存器

2. 处理中断

3. 恢复用到的寄存器

4. 用iret指令返回

iret指令的功能是： <br>

```c
pop IP
pop CS
popf
```

很显然iret是起到恢复现场的功能。

-----


### <span id = "d">除法错误中断的处理：</span>

当用div指令产生除法溢出中断时，中断类型码0将定位到中断向量表的第一个中断向量，<br>

然后进行相关的中断处理程序的执行。 <br>

div除法中断处理为显示 “Divide overflow” 同时回到操作系统。

-----


### <span id = "zg">总结：</span>

参考文献： <br>

`https://blog.csdn.net/zhaoruixiang1111/article/details/81149657` <br>

`https://blog.csdn.net/u013018721/article/details/51282095`
